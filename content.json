{"meta":{"title":"anDongCoder","subtitle":null,"description":null,"author":"Andong Li","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"Ajax学习笔记","slug":"Ajax&Json","date":"2018-10-31T11:54:36.525Z","updated":"2018-10-31T12:03:13.957Z","comments":true,"path":"2018/10/31/Ajax&Json/","link":"","permalink":"http://yoursite.com/2018/10/31/Ajax&Json/","excerpt":"","text":"Ajax学习笔记一、js原生Ajax1）ajax请求步骤1234567891011121314151617181920212223//理解原生JavaScript使用Ajax的原理和步骤// 1 创建Ajax引擎对象 var xmlhttp; if (window.XMLHttpRequest) &#123;// code for IE7+, Firefox, Chrome, Opera, Safari xmlhttp=new XMLHttpRequest(); &#125; else &#123;// code for IE6, IE5 xmlhttp=new ActiveXObject(\"Microsoft.XMLHTTP\"); &#125;//2 编写监听ajax引擎对象的回调函数。 xmlhttp对象的状态发生改变时该方法都会执行 xmlhttp.onreadystatechange = function()&#123; // 4 是服务器处理完毕 200是请求OK if(xmlhttp.readyState ==4 &amp;&amp; xmlhttp.status==200)&#123; var text = xmlhttp.responseText; //响应信息 alert(text); &#125; &#125;//3 设置请求的方式和路径 xmlhttp.open(\"get/post\",\"请求路径\")；//4 发送ajax请求 xmlhttp.send(); 2）xmlhttp对象的属性 onreadystatechange事件在ajax对象状态发生改变时,就会触发该事件对象.onreadystatechange = function(){} readyState 存有 XMLHttpRequest 的状态 0: 请求未初始化 1: 服务器连接已建立 2: 请求已接收 3: 请求处理中 4: 请求已完成，且响应已就绪 status响应状态码if(xmlhttp.readyState==4 &amp;&amp; xmlhttp.status == 200){​ 执行的代码片段} responseText获取服务器响应回来的文本信息 3）请求携带参数问题12345678910Get请求携带参数 //3 设置请求方式和请求路径 xmlhttp.open(\"get\",\"../demo1?val=\"+val); //直接将参数拼接到路径后面Post请求携带参数 //设置请求参数的mime类型 xmlhttp.setRequestHeader(\"Content-type\",\"application/x-www-form-urlencoded\"); //4 发送请求 xmlhttp.send(\"val=\"+val+\"&amp;val1=val1\"); // 携带参宿作为send函数的参数 注意：post携带参数 一定要设置请求参数的mim类型 二 jQuery框架的Ajax个人理解 jQuery一共三种方式发送ajax请求，语法形式上有一些差异，可以根据自己的习惯选择使用。 值得注意的时 回调函数的参数时服务器响应回来的数据。 1）API 请求方式 语法 GET请求 $.get(url, [data], [callback], [type]) POST请求 $.post(url, [data], [callback], [type]) AJAX请求 $.ajax([settings]) 新增GET请求 $.get([settings]) 新增POST请求 $.post([settings]) 2)代码演示方式一 $.post(url,[params],fn,[type])1234567891011- url:请求的路径 - params:请求的参数 - 格式1:字符串 key1=value1&amp;key2=value2 //第一次做案例时 这里出错 - 格式2:json格式 &#123;\"key1\":value1,\"key2\":value2&#125; 回调函数 function(data)&#123; //data:响应回来的数据 （xmlHttp.responseText） &#125;- type:返回内容的格式 默认返回text类型的数据 一般不需要自己设置,如果需要设置一般设置为 \"json\" 方式二 $.ajax({url,[settings]})123456789101112131415161718- url:请求路径- type:请求方式- data:请求参数- success:请求成功后的回调函数- error:请求失败时调用此函数- dataType:服务器返回的数据类型 一般不需要自己设置,如果需要设置一般设置为 \"json\"- async:设置是否异步提交 默认值为true(异步提交)- 例如: $.ajax(&#123; url:url, data:params, type:\"post\", success:f, error:function()&#123;alert(\"失败了\")&#125;, async:true &#125;);- 注意事项: 默认get方式提交 方式三 $.get([settings]) $.post([settings])1234567- url:请求路径- data:请求参数- success:请求成功后的回调函数- error:请求失败时调用此函数- dataType:服务器返回的数据类型 一般不需要自己设置,如果需要设置一般设置为 \"json\"- async:设置是否异步提交 默认值为true(异步提交) POST请求代码演示123456789101112131415161718192021222324252627282930// POST请求 一共三种方式 根据自己喜好使用 语法上简单的差异 var url =\"../demo2\"; var params = \"val=\"+val+\"&amp;val1=val1\"; // 方式一 jQuery POST提交 $.post(url,params,function(data)&#123; $(\"#sp1\").html(data); &#125;,\"text\") // 方式二 新增签名方式 $.post(&#123; url:url, data:params, success:function(data)&#123; $(\"#sp1\").html(data); &#125;, dataType:\"text\" &#125;) // 方式三 通用方法 $.ajax(&#123; type:\"post\", url:url, data:params, success:function(data)&#123; $(\"#sp1\").html(data); &#125;, dataType:\"text\" &#125;); GET请求代码演示123456789101112131415161718192021222324252627 var url =\"../demo2\"; var params = \"val=\"+val+\"&amp;val1=val1\";// 方式一 GET提交 $.get(url,params,function(data)&#123; $(\"#sp2\").html(data); &#125;,\"text\")*/ // 方式二 新增签名方式 $.get(&#123; url:url, data:params, success:function(data)&#123; $(\"#sp2\").html(data); &#125; &#125;) // 方式三 通用方式 $.ajax(&#123; type:\"get\", url:url, data:params, success:function(data)&#123; $(\"#sp2\").html(data); &#125;, dataType:\"text\" &#125;) 三 JSON1）三种格式1234567891011121314151617181920212223242526// 1 json对象 var jsonObj = &#123;\"name\":\"李安冬\",\"age\":18&#125;; alert(jsonObj.name+\":\"+jsonObj.age);// 2 json数组 var jsonArr = [\"张三\",\"李四\",\"王五\",\"赵六\",\"孙七\",\"仝海娜\"]; alert(jsonArr[5]);// 3 混合类型 // 分为两种 1 数组包含json对象 2 json对象包含数组 var json = &#123; class:\"黑马72\", count:94, student:[&#123;\"name\":\"李安冬\",\"age\":18&#125;,&#123;\"name\":\"仝海娜\",\"age\":3&#125;] &#125; alert(json.student[1].name+\":\"+json.student[1].age); var json1 = [ &#123;\"name\":\"李安冬\",\"age\":18&#125;, &#123;\"name\":\"仝海娜\",\"age\":3&#125;, \"heima72\", 94 ] alert(json1[1].name+\":\"+json1[1].age); 2）json转换工具常见工具类 四种jsonlib 1.导入jar包 2.使用api JSONArray.fromObject(数组或者list) JSONObject.fromObject(对象或者map) fastjson(阿里巴巴) JSON.toJSONString(str)可以转一切对象 gson(google) 使用步骤: 1.Gson g = new Gson(); 2.g.toJson(对象);可以转一切对象 Jackson开源免费的json转换工具，springmvc转换默认使用jackson 导入json相关jar包 创建核心解析对象 ObjectMapper om = new ObjectMapper(); om.writeValueAsString(obj) 3）Jackson使用转换java四种对象 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public static void main(String[] args) throws JsonProcessingException &#123; // 创建工具类对象 ObjectMapper mapper = new ObjectMapper(); // 1 数组 String [] names = &#123;\"张三\",\"李四\",\"王五\",\"赵六\",\"孙七\",\"呵呵\",\"哈哈\"&#125;; String arrJson = mapper.writeValueAsString(names); System.out.println(\"Array转成json:\"+arrJson); //2 List集合 List&lt;String&gt; nameList = new ArrayList&lt;&gt;(); nameList.add(\"宝强\"); nameList.add(\"乃亮\"); nameList.add(\"头发\"); nameList.add(\"小璐\"); nameList.add(\"马蓉\"); String listJson = mapper.writeValueAsString(nameList); System.out.println(\"List转成json:\"+listJson); // map Map&lt;String,String&gt; map = new HashMap&lt;&gt;(); map.put(\"name\",\"仝海娜\"); map.put(\"age\",\"3\"); String mapJson = mapper.writeValueAsString(map); System.out.println(\"Map转成json:\"+mapJson); // User User user = new User(\"admin\", 10); String userJson = mapper.writeValueAsString(user); System.out.println(\"User对象转成json:\"+userJson); // 实体集合 List&lt;User&gt; userList = new ArrayList&lt;&gt;(); userList.add(new User(\"迪丽热巴\",0)); userList.add(new User(\"刘诗诗\",1)); userList.add(new User(\"吴奇隆\",2)); userList.add(new User(\"景甜\",3)); userList.add(new User(\"唐嫣\",4)); userList.add(new User(\"张雨绮\",5)); String userListJson = mapper.writeValueAsString(userList); System.out.println(\"User集合对象转成json:\"+userListJson); &#125; 四 Ajax案例1）用户名校验 前端Ajax请求代码12345678910111213141516171819202122232425 &lt;script&gt; function serch(val)&#123; var params =\"username=\"+val; var url=\"anli1\"; $.post(&#123; url:url, data:params, success:function(data)&#123; //后台查询数据库后 返回 0||1 if(data==1)&#123; $(\"#nameMsg\").html(\"&lt;font color='green'&gt;√&lt;/font&gt;\") $(\"input[type='submit']\").attr(\"disabled\",false); &#125;else&#123; $(\"#nameMsg\").html(\"&lt;font color='red'&gt;用户名已存在&lt;/font&gt;\") $(\"input[type='submit']\").attr(\"disabled\",true); &#125; &#125; &#125;); &#125; &lt;/script&gt;---被校验的搜算框 &lt;td&gt;用户名:&lt;/td&gt; &lt;td&gt; &lt;input type=\"text\" name=\"username\" onblur=\"serch(this.value)\"&gt; &lt;span id=\"nameMsg\"&gt;&lt;/span&gt; &lt;/td&gt; 2）搜索框关键字匹配相关热搜词例如百度搜索时 会根据用户输入值匹配四条相关搜索词 12345678910111213141516171819202122232425262728293031 &lt;script type=\"text/javascript\"&gt; function keyUpFun(obj)&#123; var url = \"anli2\"; var params = \"keyWord=\"+obj.value; $.post(url,params,function(data)&#123; if(data.length&gt;0)&#123; $(\".show\").empty(); for(var i=0;i&lt;data.length;i++)&#123; $(\".show\").append(\"&lt;div&gt;\"+data[i]+\"&lt;/div&gt;\"); &#125; $(\".show\").show(); &#125;else&#123; $(\".show\").hide(); &#125; &#125;,\"json\"); &#125; &lt;/script&gt;--html关键代码： &lt;input type=\"text\" name=\"word\" onkeyup=\"keyUpFun(this)\"&gt; &lt;input type=\"button\" value=\"搜索一下\"&gt; &lt;div class=\"show\"&gt;&lt;/div&gt;--后台思路以及关键代码 1 键盘弹起后将搜索框中的值发到后台，进行模糊查询 最多匹配四条记录 2 将匹配的记录的字段封装到List集合中 3 用jackjson将list集合转换成json格式 并响应 sql： String sql = \"select name from user where name like ? limit 4\"; List&lt;String&gt; names = template.queryForList(sql, String.class, \"%\" + keyWord + \"%\");","categories":[],"tags":[]},{"title":"Nginx&tomcat搭建负载均衡","slug":"Nginx&tomcat搭建负载均衡","date":"2018-10-31T11:54:36.421Z","updated":"2018-10-31T12:00:38.852Z","comments":true,"path":"2018/10/31/Nginx&tomcat搭建负载均衡/","link":"","permalink":"http://yoursite.com/2018/10/31/Nginx&tomcat搭建负载均衡/","excerpt":"","text":"Nginx&amp;tomcat搭建负载均衡1、Nginx介绍以及简单使用Nginx简介​ Nginx是一种服务器软件，其最主要，最基本的功能是可以与服务器硬件结合，让程序员可以将程序发布在Nginx服务器上，让成千上万的用户可以浏览 Nginx作用 展示静态页面 反向代理（负载均衡） 邮件服务器 Nginx安装(Linux) http://nginx.org/ 下载Linux版本 解压即可 安装需要有C环境 1234Nginx是C语言开发，建议在Linux上运行，安装Nginx需要先将官网下载的源码进行编译，编译依赖gcc环境；所以需要安装gcc。//安装命令yum -y install gcc‐c++ 安装nginx 123456789101112131415//安装Nginx依赖环境，‐y表示所有提示默认选择y yum ‐y install pcre pcre‐devel yum ‐y install zlib zlib‐devel yum ‐y install openssl openssl‐devel // 解压下载下来的文件，并进入解压文件夹 tar ‐xvf nginx‐1.13.9.tar.gz ‐C/usr/local cd /usr/local/nginx‐1.13.9 //编译并安装 ./configure make make install //安装成功之后,就会在/usr/local下多出了一个nginx目录 最后一步 配置防火墙对口 /etc/sysconfig/iptables Nginx基本命令(Linux)1234567891011121 进入nginx的sbin目录2 在sbin目录下启动 ./nginx3 在sbin目录下停止 ./nginx ‐s stop 4 在sbin目录下重新加载 ./nginx ‐s reload //查看是否有nginx的线程是否存在 ps ‐ef | grep nginx // 重新加载防火墙的命令 systemctl restart iptables.serice 2、搭建负载均衡​ 使用一个nginx服务器和三台tomcat服务器实现负载均衡 windows环境windows环境下，首先解压三个tomcat服务器，修改tomcat服务器中的端口，避免多台tomcat同时启动端口占用问题。 配置tomcat端口： 修改三处端口信息 如下图: 1540972587974 配置nginx配置文件： 1540972990516 启动： 同时启动三个tomcat服务器和nginx服务器，在浏览器中访问nginx服务器，请求被代理服务器发送到不同的tomcat上进行处理。 Linux在linux系统下搭建负载均衡服务器，与windows上的思路一样，只是具体操作上的差压。 不要忘了去防火墙配置文件那里配置tomcat和端口。 ​","categories":[],"tags":[]},{"title":"IO流","slug":"IO流","date":"2018-10-31T11:54:36.410Z","updated":"2018-10-31T12:01:48.710Z","comments":true,"path":"2018/10/31/IO流/","link":"","permalink":"http://yoursite.com/2018/10/31/IO流/","excerpt":"","text":"IO流一、IO四大流字节输入流：读字节数据 ​ 共同父类: InputStream(抽象类) 字节输出流：写字节数据 ​ 共同父类：OutputStream(抽象类) 字符输入流：读字符文件 ​ 共同父类：Reader(抽象类) 字符输出流：写字符数据 ​ 共同父类：Writer(抽象类) 二、字节流2.1 字节输出流父类:OutputStream(抽象类) 12345public void close(); //关闭流public void flush(); //刷新流 public void write(byte[] b); //写一个字节数组到文件中public void write(byte[] b,int startIndex,int len);public void write(int b); FileOutputStream 1234567891011121314151617181920//a 构造方法 // 创建一个文件的字节输出流，给定文件路径 public FileOutputStream(String filepath); // 创建一个文件的字节输出流，给定对象 public FileOutputStream(File file);//b 写字节数据的三个方法 //1.写一个字节 public void write(int b); //2.写一个字节数组 public void write(byte[] b); //3.写一个字节数组的一部分 public void write(byte[] b,int startIndex,int len);//c 如何追加续写 //只要使用带有boolean类型参数的构造即可 public FileOutputSream(String filepath,boolean append); public FileOutputSteam(String filepath,boolean append); 2.2 字节输入流父类：InputStream(抽象类) 1234// 方法 public void close(); // 释放资源 public void read(); // 一次只读一个字节 public void read(byte[] bs); // 一次读取一个字节数组，返回实字节个数 FileInputStream 功能：从文件中读取字节数据 构造方法 12public FileInputStream(String pathname); public FileInputStream(File file); 读取一个字节 12345678public int read(); // 一次只读取一个字节//************标准循环***************int b; //用来保存读取的字节while((b = fis.read()) != -1)&#123; System.out.println((char)b);&#125;// 释放资源fis.close(); 读一个字节数组 12345int len = 0;byte[] bs = new byte[1024]; // 用来保存实际读取的字节while((len = fis.read(bs)) != -1)&#123; System.out.print(new String(bs,0,len));&#125; 三、字符流3.1 为什么要用字符流一个英文字母是一个字节，一个中文汉字是2-3个字节 ​ 如果使用字节流读取中文，就可能出现读一半的问题。 ​ 我们使用字符流，底层会自动判断是英文还是中文 ​ 如果是英文，只读取一个字节 ​ 如果是中文，会读取2-3个字节 3.2 字符输入流父类：Reader(抽象类) 1234// 一共有三个读取数据的方法public int read(); // 一次读取一个字符public int read(char[] chs); // 一次读取一个字符数组，返回实际读取字符个数public int read(char[] chs,int startIndex,int len); // 不常用 FileReader 构造方法 12public FileReader(String pathname);public FileReader(File file); 读取一个字符 1234int ch = 0； // 保存读取到的字符while((ch = fr.read()) != -1)&#123; System.out.println( (char)ch);&#125; 读取一个字符数组 12345int len = 0;char[] chs = new char[1024];while((len=fr.read(chs)) != -1)&#123; System.out.print(new String(chs,0,len));&#125; 3.2 字符输出流父类：Writer(抽象类) 12345678910public void close(); //释放资源public void flush(); //刷新缓冲区// 五个写入数据的方法public void write(int ch);public void write(char[] chs);public void write(char[] chs,int startIndex,int len);public void write(String str); //写入一个字符串 最常使用public void write(String str,int startIndex,int len); FileWriter 构造方法 12public FileWriter(String pathname);public FileWriter(File file); 四、缓冲流4.1. 缓冲流的作用缓冲流是对昨天学的四种流的增强(提高性能) 普通流 缓冲流 FileInputStream BufferedInputStream FileOutputStream BufferedOutputStream FileReader BuffereReader FileWriter BufferedWriter 为什么缓冲流的性能高: 因为缓冲流自带缓冲区,提高性能 降低和硬盘打交道次数 4.2 字节缓冲流介绍和使用12345// 构造方法public BufferedInputStream(InputStream fis);public BufferedOutputStream(OutputStream fos);//方法和字节流相同 4.3 字符缓冲流的介绍和使用 构造方法 12public BufferedReader(Reader fr);public BufferedWriter(Writer fw) 特有方法 BufferedReader多一个特有方法: 123456public String readline();//****************标准循环代码***************String line = null;while ((line = br.readLine()) != null) &#123; System.out.println(line);&#125; BufferedWriter多一个特有方法 1public void newline(); //写一个跨平台的换行符五、转换流 五、转换流 转换流就是字符流和字节流之间的桥梁 –根据自己需求选择使用 转换流 5.1 InputStreamReader字节流通向字符流的桥梁 123//属于字节流public InputStreamReader(FileInputStream fis); //默认使用UTF8读取文件,一次读3个字节public InputStreamReader(FileInputStream fis,String charsetName); //指定编码读文件 5.2 OutputStreamWriter字符流通向字节流的桥梁 12public OutputStreamWriter(FileOutputStream fos); //默认UTF-8public OutputStreamWriter(FileOutputStream fos,String charsetName);//指定码表","categories":[],"tags":[]},{"title":"Linux常用命令","slug":"Linux常用命令","date":"2018-10-31T11:10:52.715Z","updated":"2018-10-31T11:46:22.864Z","comments":true,"path":"2018/10/31/Linux常用命令/","link":"","permalink":"http://yoursite.com/2018/10/31/Linux常用命令/","excerpt":"","text":"Linux常用命令一、目录操作1、ls[参数] （查看）参数解释 -l 以详形式查询当前目录下所有的文件和目录，不包括隐藏文件和目录 -a 以精简形式查询当前目录下所有文件和目录，包含隐藏文件和目录 命令 12345cd / 进入根目录ls 以精简形式查询当前目录下所有文件和目录ls -l 缩写：ll 以详形式查询当前目录下所有的文件和目录 ls -a 精简形式查询所有文件和目录ls -la 详细形式查询目录下的所有文件和目录 1540716587830 2、目录2.1 切换目录命令12345cd ~ 当前用户目录cd / 根目录cd - 上一次访问的目录cd ../ 上一级目录cd 缺省当前用户目录 2.2 显示当前工作目录命令 1pwd 显示当前工作目录 3、创建目录1234cd / 位于根目录mkdir aaa 在当前目录下创建aaa目录，相对路径mkdir ./bbb 在当前目录下创建bbb目录，相对路径mkdir /ccc 在根目录下创建ccc目录，绝对路径 4、查找语法：find目录 -name ‘条件’ 命令： 1234cd /find / -name 'b' 查询根目录下（包括子目录），名为b的目录和文件find / -name 'b*' 查询根目录下（包括子目录），名为b开头的目录和文件在Linux中，ctr+c 强行终止程序执行 5、修改语法：mv 旧目录 新目录 对目录或者文件重命名 命令 12cd /mv aaa bbb 将根目录下的aaa目录修改为bbb 6、剪切语法：mv 源目录位置 新目录位置 对目录进行移动 命令 123cd /mv /aaa /bbb 将根目录下的aaa目录移动到bbb目录下。mv bbb /usr/bbbb 将当前目录下的bbb目录移动到usr目录下，且修改名为bbbb 7、拷贝语法：cp[参数] 目录 目录新位置 参数解释: -r：若给出的源文件是一个目录文件，此时将复制该目录下所有的子目录和文件 -f：覆盖已经存在的目标文件而不给出提示 12345cd /cp -r /aaa /bbb 将/目录下的aaa目录复制到/bbb目录下.cp -r /aaa /bbb/aaaa 将/目录下的aaa目录复制到/bbb目录下，且修改名为aaaa //当路径中后面的目录不存在是最后一级目录是修改拷贝的目录名 //当修改名称时只能最后一级的目录不存在 如果存在两级目录不存在则报错 1540798574355 8、删除语法：rm [参数] 目录 参数解释： -f 即使原档案属性设为唯读，亦直接删除，无需逐一确认。 -r 将目录及以下之档案亦逐一删除。 命令： 1234cd /rm -r /aaa 询问式删除/目录下的aaa目录 如果aaa目录下还存在子目录，则进入aaa目录下的所有子目录，依次询问rm -rf /bbb 强行删除/目录下的bbb目录 连同子目录一起删除 二、文件操作1、增加语法：touch 文件名 命令： 1234cd /aaaatouch a.java //在aaaa目录下创建a.java文件touch b.txttouch c.xml 2、查看语法：cat/more/less/head/tall 文件名 以只读方式查看文件的内容 命令： 12345678910cd /aaaacat a.java //查看a.java文件的最后一页内容more a.java //从第一页开始查看，回车键出现一行，空格键出一页less a.java //从第一页开始查看，回车键出现一行，空格键出一页 // 支持使用pageDown和pageUp翻页，q退出 head a.java //查看钱10行tail a.java //查看后10行head -n 7 a.java //查看前7行内容tail -n 7 a.java //查看后7行内容 3、删除语法：rm [参数] 文件 参数解释: -r 递归处理，对于文件删除，这个参数可带可不带 -f 强制删除文件，它不会询问你 命令： 12cd /aaaarm -rf a.java //强制删除当前目录下的a.java文件 4、修改 vi/vim使用vi vim对文件进行编辑修改。 使用步骤： 1 用vim打开文件 2 按 i 进入插入模式 进行编辑操作 3 编辑完成后 按 esc键 从插入模式退出到一半模式 4 输入：进入底行命令模式 输入 wq 退出 快捷键： 编辑模式快捷键 快捷键 作用 yy 复制当前行 p 粘贴 dd 删除当前行 G 到文件的最后一行 底行模式快捷键 快捷键 作用 :wq 保存退出 :q 退出vi(文件五修改的情况下) :q! 不保存强制退出 4、压缩windows中的压缩文件的扩展名：.zip或者rar Linux中的打包文件扩展名：.tar Linux中的压缩文件扩展名：.gz Linux中打包压缩的文件扩展名：.tar .gz 4.1 打包压缩语法：tar[参数] 打包压缩后的文件名 要打包压缩的文件名 参数解释： -c 创建新的文件(必选项) -f 文件名由命令台设置(必选项) -v 输出文件清单(可选项) -z 自动识别压缩或解压(可选项) 常用方式： tar -zcvf 12345678910cd /mkdir aaacd aaatouch a.javatouch b.javatouch c.javatar -zcvf haha.tar.gz a.java b.java c.java或tar -zcvf haha.tar.gz ./* //将当前目录项的所有文件打包压缩成haha.tar.gz文件 4.2 解压缩压缩语法：tar[参数] 压缩文件 解压后的文件在当前的目录中 解压语法：tar [参数] 压缩文件 -C目录 解压后的文件放入制定的目录中，C是大写,后面没有空格 参数解释： -x 取出文件中的内容(必选项) -f 文件名由命令台设置(必选项) -v 输出文件清单(可选项) -z 自动识别压缩或解压(可选项) 命令： 12tar -xvf haha.tar.gz //解压到当前目录下tar -xvf haha.tar.gz -C/usr/local //解压文件到制定的目录下 三、其他1、查看进程语法：ps[参数] 常用参数组合： ps-ef ps-au 参数解释： 无 显示当前用户通过终端启动所有的进程 -a显示所有用户通过终端启动的所有进程 -u 显示所有用户通过终端启动的所有进程的详细信息 -x 显示所有用户通过终端和非终端启动的所有进程的详细信息，内容相当多，少用 -f 显示UID PPIP C STIME栏位 命令： 1ps au 显示所有有用通过终端启动的所有进程的详细信息 2、杀死进程语法：kill[参数] 进程号 先用ps -au 或 ps -ef 来确认一下当前需要杀死进程号，再用kill进程号 将这个进程结束 参数解释： 无 普通式删除进程号对应的进程 -9 强制式删除进程号对应的进程 命令： 12kill 1128 //杀死1128进程号，如果杀不了，用下面的命令kill -9 1128 //强制性杀死1128进程号 3、搜索语法：grep[参数] 要搜索的字符串 文件名 参数解释： -i 搜索时不区分大小写 -n 显示匹配行及行号 大小写敏感 -v 显示不匹配行及行号，大小写敏感 命令： 12345grep as 123.txt //在123.txt文件中搜索as字符串，区分大小写，显示行grep -n as 123.txt //在123.txt文件中搜索as字符串，区分大小写，显示行及行号grep -v as 123.txt //在123.txt文件中搜索as字符串，区分大小写，显示没搜到的行grep -i as 123.txt //在123.txt文件中搜索as字符串，不区分大小写，显示行grep -ni \"Q q\" 123.txt //在123.txt文件中搜索Q q字符串，不区分大小写，显示行及行号 4、关机语法：halt 命令： hatl 正常关闭安装的linux虚拟机 5、重启语法：reboot 命令：reboot 重新启动安装Linux的虚拟机 4、文件权限4.1 权限的简介 1540804356351 1540804388251 4.2 操作权限chmod(change mode) 功能：变更文件或目录的权限 参数： 递归处理，将制定目录下的所有文件及子目录一并删除。 命令： 123chmod u+x 1.txt 给1.txt的拥有者添加执行的权限chmod 755 1.txt chmod 777 a.txt 给所有人添加所有属性 ###","categories":[],"tags":[]}]}